/*

Shortest Superstring Problem
Given a set of n strings arr[], find the smallest string that contains each string in the given set as substring.
We may assume that no string in arr[] is substring of another string.

Examples:

Input:  arr[] = {"geeks", "quiz", "for"}
Output: geeksquizfor

Input:  arr[] = {"catg", "ctaagt", "gcta", "ttca", "atgcatc"}
Output: gctaagttcatgcatc


 */
package strings;

import java.util.Arrays;

/**
 * Created by poorvank.b on 01/04/18.
 */
public class ShortestSuperString {

    public String findShortestSuperString(String[] arr) {

        int n=arr.length;

        System.out.println(Arrays.toString(arr));

        while (n!=1) {

            int left=0,right=0;
            int maxLength = Integer.MIN_VALUE;
            String resString = "";

            for (int i=0;i<n;i++) {
                for (int j=i+1;j<n;j++) {

                    StringBuilder unifiedString=new StringBuilder();
                    int res = findMaxString(arr[i],arr[j],unifiedString);

                    if(maxLength<res) {
                        maxLength = res;
                        left=i;
                        right=j;
                        resString=unifiedString.toString();
                    }

                }
            }

            System.out.println(resString+" "+maxLength);
            n--;
            if(maxLength==Integer.MIN_VALUE) {
                arr[0]+=arr[n];
            } else {
                arr[left]=resString;
                arr[right]=arr[n];
            }
            System.out.println(Arrays.toString(arr));

        }



        return arr[0];

    }


    //"catgc", "atgcatc"
    private int findMaxString(String s1,String s2,StringBuilder s) {

        int max=0;

        int len = Math.min(s1.length(),s2.length());

        // check first i characters of s1 matches last i characters of s2
        for (int i=1;i<len;i++) {

            if(s1.substring(0,i).equals(s2.substring(len-i)) && max<i) {
                max=i;
                s.append(s2).append(s1.substring(i));
            }

        }

        // check first i characters of s2 match last i characters of s1
        for (int i=0;i<len;i++) {

            if(s2.substring(0,i).contains(s1.substring(len-i)) && max<i) {
                max=i;
                s.append(s1).append(s2.substring(i));
            }

        }

        return max;

    }

    public static void main(String[] args) {
        String[] arr = new String[]{"catgc","ctaagt", "gcta", "ttca","atgcatc"};
        System.out.println(new ShortestSuperString().findShortestSuperString(arr));
    }

}

/*

Shortest Superstring Greedy Approximate Algorithm
Shortest Superstring Problem is a NP Hard problem. A solution that always finds shortest superstring takes exponential time.
Below is an Approximate Greedy algorithm.

Let arr[] be given set of strings.

1) Create an auxiliary array of strings, temp[].  Copy contents
   of arr[] to temp[]

2) While temp[] contains more than one strings
     a) Find the most overlapping string pair in temp[]. Let this
        pair be 'a' and 'b'.
     b) Replace 'a' and 'b' with the string obtained after combining
        them.

3) The only string left in temp[] is the result, return it.

Two strings are overlapping if prefix of one string is same suffix of other string or vice verse. The maximum overlap mean length of the matching prefix and suffix is maximum.

Working of above Algorithm:



arr[] = {"catgc", "ctaagt", "gcta", "ttca", "atgcatc"}
Initialize:
temp[] = {"catgc", "ctaagt", "gcta", "ttca", "atgcatc"}

The most overlapping strings are "catgc" and "atgcatc"
(Suffix of length 4 of "catgc" is same as prefix of "atgcatc")
Replace two strings with "catgcatc", we get
temp[] = {"catgcatc", "ctaagt", "gcta", "ttca"}

The most overlapping strings are "ctaagt" and "gcta"
(Prefix of length 3 of "ctaagt" is same as suffix of "gcta")
Replace two strings with "gctaagt", we get
temp[] = {"catgcatc", "gctaagt", "ttca"}

The most overlapping strings are "catgcatc" and "ttca"
(Prefix of length 2 of "catgcatc" as suffix of "ttca")
Replace two strings with "ttcatgcatc", we get
temp[] = {"ttcatgcatc", "gctaagt"}

Now there are only two strings in temp[], after combing
the two in optimal way, we get tem[] = {"gctaagttcatgcatc"}

Since temp[] has only one string now, return it.


Performance of above algorithm:
The above Greedy Algorithm is proved to be 4 approximate (i.e., length of the superstring generated by this algorithm is never beyond 4
times the shortest possible superstring). This algorithm is conjectured to 2 approximate (nobody has found case where it generates more
than twice the worst). Conjectured worst case example is {a(b^k), bkc, bk+1}. For example {“abb”, “bbc”, “bbb”}, the above algorithm may
generate “abbcbbb” (if “abb” and “bbc” are picked as first pair), but the actual shortest superstring is “abbbc”. Here ratio is 7/5,
but for large k, ration approaches 2.


https://www.geeksforgeeks.org/shortest-superstring-problem-set-2-using-set-cover/

 */
